#include "ntru-oqxt-setup.h"

#define TEMPALLOC
#define CRYPTO_SECRETKEYBYTES   1281
#define CRYPTO_PUBLICKEYBYTES   897
#define CRYPTO_BYTES            690
#define FALCON_KEYGEN_TEMP_9    14336


#define Q0I   12287
#define R1      4091
#define R2    10952


// For p_l_dash = 24407041 = 2^25
#define Q0I_large   41168
#define R_large      2523
#define R2_large    22298801

/*
 * Table for NTT, binary case:
 *   GMb[x] = R1*(g^rev(x)) mod q
 * where g = 7 (it is a 2048-th primitive root of 1 modulo q)
 * and rev() is the bit-reversal function over 10 bits.
 */
static const uint16_t GMb[] = {
	 4091,  7888, 11060, 11208,  6960,  4342,  6275,  9759,
	 1591,  6399,  9477,  5266,   586,  5825,  7538,  9710,
	 1134,  6407,  1711,   965,  7099,  7674,  3743,  6442,
	10414,  8100,  1885,  1688,  1364, 10329, 10164,  9180,
	12210,  6240,   997,   117,  4783,  4407,  1549,  7072,
	 2829,  6458,  4431,  8877,  7144,  2564,  5664,  4042,
	12189,   432, 10751,  1237,  7610,  1534,  3983,  7863,
	 2181,  6308,  8720,  6570,  4843,  1690,    14,  3872,
	 5569,  9368, 12163,  2019,  7543,  2315,  4673,  7340,
	 1553,  1156,  8401, 11389,  1020,  2967, 10772,  7045,
	 3316, 11236,  5285, 11578, 10637, 10086,  9493,  6180,
	 9277,  6130,  3323,   883, 10469,   489,  1502,  2851,
	11061,  9729,  2742, 12241,  4970, 10481, 10078,  1195,
	  730,  1762,  3854,  2030,  5892, 10922,  9020,  5274,
	 9179,  3604,  3782, 10206,  3180,  3467,  4668,  2446,
	 7613,  9386,   834,  7703,  6836,  3403,  5351, 12276,
	 3580,  1739, 10820,  9787, 10209,  4070, 12250,  8525,
	10401,  2749,  7338, 10574,  6040,   943,  9330,  1477,
	 6865,  9668,  3585,  6633, 12145,  4063,  3684,  7680,
	 8188,  6902,  3533,  9807,  6090,   727, 10099,  7003,
	 6945,  1949,  9731, 10559,  6057,   378,  7871,  8763,
	 8901,  9229,  8846,  4551,  9589, 11664,  7630,  8821,
	 5680,  4956,  6251,  8388, 10156,  8723,  2341,  3159,
	 1467,  5460,  8553,  7783,  2649,  2320,  9036,  6188,
	  737,  3698,  4699,  5753,  9046,  3687,    16,   914,
	 5186, 10531,  4552,  1964,  3509,  8436,  7516,  5381,
	10733,  3281,  7037,  1060,  2895,  7156,  8887,  5357,
	 6409,  8197,  2962,  6375,  5064,  6634,  5625,   278,
	  932, 10229,  8927,  7642,   351,  9298,   237,  5858,
	 7692,  3146, 12126,  7586,  2053, 11285,  3802,  5204,
	 4602,  1748, 11300,   340,  3711,  4614,   300, 10993,
	 5070, 10049, 11616, 12247,  7421, 10707,  5746,  5654,
	 3835,  5553,  1224,  8476,  9237,  3845,   250, 11209,
	 4225,  6326,  9680, 12254,  4136,  2778,   692,  8808,
	 6410,  6718, 10105, 10418,  3759,  7356, 11361,  8433,
	 6437,  3652,  6342,  8978,  5391,  2272,  6476,  7416,
	 8418, 10824, 11986,  5733,   876,  7030,  2167,  2436,
	 3442,  9217,  8206,  4858,  5964,  2746,  7178,  1434,
	 7389,  8879, 10661, 11457,  4220,  1432, 10832,  4328,
	 8557,  1867,  9454,  2416,  3816,  9076,   686,  5393,
	 2523,  4339,  6115,   619,   937,  2834,  7775,  3279,
	 2363,  7488,  6112,  5056,   824, 10204, 11690,  1113,
	 2727,  9848,   896,  2028,  5075,  2654, 10464,  7884,
	12169,  5434,  3070,  6400,  9132, 11672, 12153,  4520,
	 1273,  9739, 11468,  9937, 10039,  9720,  2262,  9399,
	11192,   315,  4511,  1158,  6061,  6751, 11865,   357,
	 7367,  4550,   983,  8534,  8352, 10126,  7530,  9253,
	 4367,  5221,  3999,  8777,  3161,  6990,  4130, 11652,
	 3374, 11477,  1753,   292,  8681,  2806, 10378, 12188,
	 5800, 11811,  3181,  1988,  1024,  9340,  2477, 10928,
	 4582,  6750,  3619,  5503,  5233,  2463,  8470,  7650,
	 7964,  6395,  1071,  1272,  3474, 11045,  3291, 11344,
	 8502,  9478,  9837,  1253,  1857,  6233,  4720, 11561,
	 6034,  9817,  3339,  1797,  2879,  6242,  5200,  2114,
	 7962,  9353, 11363,  5475,  6084,  9601,  4108,  7323,
	10438,  9471,  1271,   408,  6911,  3079,   360,  8276,
	11535,  9156,  9049, 11539,   850,  8617,   784,  7919,
	 8334, 12170,  1846, 10213, 12184,  7827, 11903,  5600,
	 9779,  1012,   721,  2784,  6676,  6552,  5348,  4424,
	 6816,  8405,  9959,  5150,  2356,  5552,  5267,  1333,
	 8801,  9661,  7308,  5788,  4910,   909, 11613,  4395,
	 8238,  6686,  4302,  3044,  2285, 12249,  1963,  9216,
	 4296, 11918,   695,  4371,  9793,  4884,  2411, 10230,
	 2650,   841,  3890, 10231,  7248,  8505, 11196,  6688,
	 4059,  6060,  3686,  4722, 11853,  5816,  7058,  6868,
	11137,  7926,  4894, 12284,  4102,  3908,  3610,  6525,
	 7938,  7982, 11977,  6755,   537,  4562,  1623,  8227,
	11453,  7544,   906, 11816,  9548, 10858,  9703,  2815,
	11736,  6813,  6979,   819,  8903,  6271, 10843,   348,
	 7514,  8339,  6439,   694,   852,  5659,  2781,  3716,
	11589,  3024,  1523,  8659,  4114, 10738,  3303,  5885,
	 2978,  7289, 11884,  9123,  9323, 11830,    98,  2526,
	 2116,  4131, 11407,  1844,  3645,  3916,  8133,  2224,
	10871,  8092,  9651,  5989,  7140,  8480,  1670,   159,
	10923,  4918,   128,  7312,   725,  9157,  5006,  6393,
	 3494,  6043, 10972,  6181, 11838,  3423, 10514,  7668,
	 3693,  6658,  6905, 11953, 10212, 11922,  9101,  8365,
	 5110,    45,  2400,  1921,  4377,  2720,  1695,    51,
	 2808,   650,  1896,  9997,  9971, 11980,  8098,  4833,
	 4135,  4257,  5838,  4765, 10985, 11532,   590, 12198,
	  482, 12173,  2006,  7064, 10018,  3912, 12016, 10519,
	11362,  6954,  2210,   284,  5413,  6601,  3865, 10339,
	11188,  6231,   517,  9564, 11281,  3863,  1210,  4604,
	 8160, 11447,   153,  7204,  5763,  5089,  9248, 12154,
	11748,  1354,  6672,   179,  5532,  2646,  5941, 12185,
	  862,  3158,   477,  7279,  5678,  7914,  4254,   302,
	 2893, 10114,  6890,  9560,  9647, 11905,  4098,  9824,
	10269,  1353, 10715,  5325,  6254,  3951,  1807,  6449,
	 5159,  1308,  8315,  3404,  1877,  1231,   112,  6398,
	11724, 12272,  7286,  1459, 12274,  9896,  3456,   800,
	 1397, 10678,   103,  7420,  7976,   936,   764,   632,
	 7996,  8223,  8445,  7758, 10870,  9571,  2508,  1946,
	 6524, 10158,  1044,  4338,  2457,  3641,  1659,  4139,
	 4688,  9733, 11148,  3946,  2082,  5261,  2036, 11850,
	 7636, 12236,  5366,  2380,  1399,  7720,  2100,  3217,
	10912,  8898,  7578, 11995,  2791,  1215,  3355,  2711,
	 2267,  2004,  8568, 10176,  3214,  2337,  1750,  4729,
	 4997,  7415,  6315, 12044,  4374,  7157,  4844,   211,
	 8003, 10159,  9290, 11481,  1735,  2336,  5793,  9875,
	 8192,   986,  7527,  1401,   870,  3615,  8465,  2756,
	 9770,  2034, 10168,  3264,  6132,    54,  2880,  4763,
	11805,  3074,  8286,  9428,  4881,  6933,  1090, 10038,
	 2567,   708,   893,  6465,  4962, 10024,  2090,  5718,
	10743,   780,  4733,  4623,  2134,  2087,  4802,   884,
	 5372,  5795,  5938,  4333,  6559,  7549,  5269, 10664,
	 4252,  3260,  5917, 10814,  5768,  9983,  8096,  7791,
	 6800,  7491,  6272,  1907, 10947,  6289, 11803,  6032,
	11449,  1171,  9201,  7933,  2479,  7970, 11337,  7062,
	 8911,  6728,  6542,  8114,  8828,  6595,  3545,  4348,
	 4610,  2205,  6999,  8106,  5560, 10390,  9321,  2499,
	 2413,  7272,  6881, 10582,  9308,  9437,  3554,  3326,
	 5991, 11969,  3415, 12283,  9838, 12063,  4332,  7830,
	11329,  6605, 12271,  2044, 11611,  7353, 11201, 11582,
	 3733,  8943,  9978,  1627,  7168,  3935,  5050,  2762,
	 7496, 10383,   755,  1654, 12053,  4952, 10134,  4394,
	 6592,  7898,  7497,  8904, 12029,  3581, 10748,  5674,
	10358,  4901,  7414,  8771,   710,  6764,  8462,  7193,
	 5371,  7274, 11084,   290,  7864,  6827, 11822,  2509,
	 6578,  4026,  5807,  1458,  5721,  5762,  4178,  2105,
	11621,  4852,  8897,  2856, 11510,  9264,  2520,  8776,
	 7011,  2647,  1898,  7039,  5950, 11163,  5488,  6277,
	 9182, 11456,   633, 10046, 11554,  5633,  9587,  2333,
	 7008,  7084,  5047,  7199,  9865,  8997,   569,  6390,
	10845,  9679,  8268, 11472,  4203,  1997,     2,  9331,
	  162,  6182,  2000,  3649,  9792,  6363,  7557,  6187,
	 8510,  9935,  5536,  9019,  3706, 12009,  1452,  3067,
	 5494,  9692,  4865,  6019,  7106,  9610,  4588, 10165,
	 6261,  5887,  2652, 10172,  1580, 10379,  4638,  9949
};


/*
 * Table for inverse NTT, binary case:
 *   iGMb[x] = R1*((1/g)^rev(x)) mod q
 * Since g = 7, 1/g = 8778 mod 12289.
 */
static const uint16_t iGMb[] = {
	 4091,  4401,  1081,  1229,  2530,  6014,  7947,  5329,
	 2579,  4751,  6464, 11703,  7023,  2812,  5890, 10698,
	 3109,  2125,  1960, 10925, 10601, 10404,  4189,  1875,
	 5847,  8546,  4615,  5190, 11324, 10578,  5882, 11155,
	 8417, 12275, 10599,  7446,  5719,  3569,  5981, 10108,
	 4426,  8306, 10755,  4679, 11052,  1538, 11857,   100,
	 8247,  6625,  9725,  5145,  3412,  7858,  5831,  9460,
	 5217, 10740,  7882,  7506, 12172, 11292,  6049,    79,
	   13,  6938,  8886,  5453,  4586, 11455,  2903,  4676,
	 9843,  7621,  8822,  9109,  2083,  8507,  8685,  3110,
	 7015,  3269,  1367,  6397, 10259,  8435, 10527, 11559,
	11094,  2211,  1808,  7319,    48,  9547,  2560,  1228,
	 9438, 10787, 11800,  1820, 11406,  8966,  6159,  3012,
	 6109,  2796,  2203,  1652,   711,  7004,  1053,  8973,
	 5244,  1517,  9322, 11269,   900,  3888, 11133, 10736,
	 4949,  7616,  9974,  4746, 10270,   126,  2921,  6720,
	 6635,  6543,  1582,  4868,    42,   673,  2240,  7219,
	 1296, 11989,  7675,  8578, 11949,   989, 10541,  7687,
	 7085,  8487,  1004, 10236,  4703,   163,  9143,  4597,
	 6431, 12052,  2991, 11938,  4647,  3362,  2060, 11357,
	12011,  6664,  5655,  7225,  5914,  9327,  4092,  5880,
	 6932,  3402,  5133,  9394, 11229,  5252,  9008,  1556,
	 6908,  4773,  3853,  8780, 10325,  7737,  1758,  7103,
	11375, 12273,  8602,  3243,  6536,  7590,  8591, 11552,
	 6101,  3253,  9969,  9640,  4506,  3736,  6829, 10822,
	 9130,  9948,  3566,  2133,  3901,  6038,  7333,  6609,
	 3468,  4659,   625,  2700,  7738,  3443,  3060,  3388,
	 3526,  4418, 11911,  6232,  1730,  2558, 10340,  5344,
	 5286,  2190, 11562,  6199,  2482,  8756,  5387,  4101,
	 4609,  8605,  8226,   144,  5656,  8704,  2621,  5424,
	10812,  2959, 11346,  6249,  1715,  4951,  9540,  1888,
	 3764,    39,  8219,  2080,  2502,  1469, 10550,  8709,
	 5601,  1093,  3784,  5041,  2058,  8399, 11448,  9639,
	 2059,  9878,  7405,  2496,  7918, 11594,   371,  7993,
	 3073, 10326,    40, 10004,  9245,  7987,  5603,  4051,
	 7894,   676, 11380,  7379,  6501,  4981,  2628,  3488,
	10956,  7022,  6737,  9933,  7139,  2330,  3884,  5473,
	 7865,  6941,  5737,  5613,  9505, 11568, 11277,  2510,
	 6689,   386,  4462,   105,  2076, 10443,   119,  3955,
	 4370, 11505,  3672, 11439,   750,  3240,  3133,   754,
	 4013, 11929,  9210,  5378, 11881, 11018,  2818,  1851,
	 4966,  8181,  2688,  6205,  6814,   926,  2936,  4327,
	10175,  7089,  6047,  9410, 10492,  8950,  2472,  6255,
	  728,  7569,  6056, 10432, 11036,  2452,  2811,  3787,
	  945,  8998,  1244,  8815, 11017, 11218,  5894,  4325,
	 4639,  3819,  9826,  7056,  6786,  8670,  5539,  7707,
	 1361,  9812,  2949, 11265, 10301,  9108,   478,  6489,
	  101,  1911,  9483,  3608, 11997, 10536,   812,  8915,
	  637,  8159,  5299,  9128,  3512,  8290,  7068,  7922,
	 3036,  4759,  2163,  3937,  3755, 11306,  7739,  4922,
	11932,   424,  5538,  6228, 11131,  7778, 11974,  1097,
	 2890, 10027,  2569,  2250,  2352,   821,  2550, 11016,
	 7769,   136,   617,  3157,  5889,  9219,  6855,   120,
	 4405,  1825,  9635,  7214, 10261, 11393,  2441,  9562,
	11176,   599,  2085, 11465,  7233,  6177,  4801,  9926,
	 9010,  4514,  9455, 11352, 11670,  6174,  7950,  9766,
	 6896, 11603,  3213,  8473,  9873,  2835, 10422,  3732,
	 7961,  1457, 10857,  8069,   832,  1628,  3410,  4900,
	10855,  5111,  9543,  6325,  7431,  4083,  3072,  8847,
	 9853, 10122,  5259, 11413,  6556,   303,  1465,  3871,
	 4873,  5813, 10017,  6898,  3311,  5947,  8637,  5852,
	 3856,   928,  4933,  8530,  1871,  2184,  5571,  5879,
	 3481, 11597,  9511,  8153,    35,  2609,  5963,  8064,
	 1080, 12039,  8444,  3052,  3813, 11065,  6736,  8454,
	 2340,  7651,  1910, 10709,  2117,  9637,  6402,  6028,
	 2124,  7701,  2679,  5183,  6270,  7424,  2597,  6795,
	 9222, 10837,   280,  8583,  3270,  6753,  2354,  3779,
	 6102,  4732,  5926,  2497,  8640, 10289,  6107, 12127,
	 2958, 12287, 10292,  8086,   817,  4021,  2610,  1444,
	 5899, 11720,  3292,  2424,  5090,  7242,  5205,  5281,
	 9956,  2702,  6656,   735,  2243, 11656,   833,  3107,
	 6012,  6801,  1126,  6339,  5250, 10391,  9642,  5278,
	 3513,  9769,  3025,   779,  9433,  3392,  7437,   668,
	10184,  8111,  6527,  6568, 10831,  6482,  8263,  5711,
	 9780,   467,  5462,  4425, 11999,  1205,  5015,  6918,
	 5096,  3827,  5525, 11579,  3518,  4875,  7388,  1931,
	 6615,  1541,  8708,   260,  3385,  4792,  4391,  5697,
	 7895,  2155,  7337,   236, 10635, 11534,  1906,  4793,
	 9527,  7239,  8354,  5121, 10662,  2311,  3346,  8556,
	  707,  1088,  4936,   678, 10245,    18,  5684,   960,
	 4459,  7957,   226,  2451,     6,  8874,   320,  6298,
	 8963,  8735,  2852,  2981,  1707,  5408,  5017,  9876,
	 9790,  2968,  1899,  6729,  4183,  5290, 10084,  7679,
	 7941,  8744,  5694,  3461,  4175,  5747,  5561,  3378,
	 5227,   952,  4319,  9810,  4356,  3088, 11118,   840,
	 6257,   486,  6000,  1342, 10382,  6017,  4798,  5489,
	 4498,  4193,  2306,  6521,  1475,  6372,  9029,  8037,
	 1625,  7020,  4740,  5730,  7956,  6351,  6494,  6917,
	11405,  7487, 10202, 10155,  7666,  7556, 11509,  1546,
	 6571, 10199,  2265,  7327,  5824, 11396, 11581,  9722,
	 2251, 11199,  5356,  7408,  2861,  4003,  9215,   484,
	 7526,  9409, 12235,  6157,  9025,  2121, 10255,  2519,
	 9533,  3824,  8674, 11419, 10888,  4762, 11303,  4097,
	 2414,  6496,  9953, 10554,   808,  2999,  2130,  4286,
	12078,  7445,  5132,  7915,   245,  5974,  4874,  7292,
	 7560, 10539,  9952,  9075,  2113,  3721, 10285, 10022,
	 9578,  8934, 11074,  9498,   294,  4711,  3391,  1377,
	 9072, 10189,  4569, 10890,  9909,  6923,    53,  4653,
	  439, 10253,  7028, 10207,  8343,  1141,  2556,  7601,
	 8150, 10630,  8648,  9832,  7951, 11245,  2131,  5765,
	10343,  9781,  2718,  1419,  4531,  3844,  4066,  4293,
	11657, 11525, 11353,  4313,  4869, 12186,  1611, 10892,
	11489,  8833,  2393,    15, 10830,  5003,    17,   565,
	 5891, 12177, 11058, 10412,  8885,  3974, 10981,  7130,
	 5840, 10482,  8338,  6035,  6964,  1574, 10936,  2020,
	 2465,  8191,   384,  2642,  2729,  5399,  2175,  9396,
	11987,  8035,  4375,  6611,  5010, 11812,  9131, 11427,
	  104,  6348,  9643,  6757, 12110,  5617, 10935,   541,
	  135,  3041,  7200,  6526,  5085, 12136,   842,  4129,
	 7685, 11079,  8426,  1008,  2725, 11772,  6058,  1101,
	 1950,  8424,  5688,  6876, 12005, 10079,  5335,   927,
	 1770,   273,  8377,  2271,  5225, 10283,   116, 11807,
	   91, 11699,   757,  1304,  7524,  6451,  8032,  8154,
	 7456,  4191,   309,  2318,  2292, 10393, 11639,  9481,
	12238, 10594,  9569,  7912, 10368,  9889, 12244,  7179,
	 3924,  3188,   367,  2077,   336,  5384,  5631,  8596,
	 4621,  1775,  8866,   451,  6108,  1317,  6246,  8795,
	 5896,  7283,  3132, 11564,  4977, 12161,  7371,  1366,
	12130, 10619,  3809,  5149,  6300,  2638,  4197,  1418,
	10065,  4156,  8373,  8644, 10445,   882,  8158, 10173,
	 9763, 12191,   459,  2966,  3166,   405,  5000,  9311,
	 6404,  8986,  1551,  8175,  3630, 10766,  9265,   700,
	 8573,  9508,  6630, 11437, 11595,  5850,  3950,  4775,
	11941,  1446,  6018,  3386, 11470,  5310,  5476,   553,
	 9474,  2586,  1431,  2741,   473, 11383,  4745,   836,
	 4062, 10666,  7727, 11752,  5534,   312,  4307,  4351,
	 5764,  8679,  8381,  8187,     5,  7395,  4363,  1152,
	 5421,  5231,  6473,   436,  7567,  8603,  6229,  8230
};


static const uint32_t GMb_large[] = {
	65536, 12973364, 8770880, 13947155, 17328434, 4908543, 2878718, 6062702, 12572472, 
	3936934, 13208275, 19730568, 10953681, 11828114, 5236040, 11931819, 15752049, 
	23890657, 12070276, 1823739, 841701, 12216673, 2601177, 22866132, 12980370, 
	1520237, 13597699, 931887, 4629263, 3227807, 3389581, 6127157, 3254322, 
	6188301, 4741894, 20835948, 14262742, 15327555, 16946294, 24046780, 1079758, 
	24225514, 1735605, 10099602, 17762729, 19645267, 9065257, 20325140, 15278006, 
	22433110, 10193483, 2941733, 17892086, 17352139, 16819658, 19470335, 1162895, 
	22739847, 18463305, 11839852, 3258887, 12405694, 13146887, 88184, 5410697, 
	1296011, 19448050, 19975479, 5718759, 6877814, 10575742, 22423368, 16998768, 
	21775054, 16200878, 7351923, 16742486, 16355343, 4068438, 4573753, 6691027, 
	2570063, 22571028, 13057943, 21387537, 1072286, 21107115, 6456005, 20246003, 
	3158926, 8434322, 6943141, 23714099, 5440458, 7320822, 19879639, 22248231, 
	16385861, 18503807, 15188859, 15392526, 6407116, 24185279, 10959711, 13517846, 
	9258789, 19459106, 4836055, 4517356, 17123890, 22711297, 18216301, 1883190, 
	24136781, 8391602, 5112513, 13556640, 5303905, 7442153, 19075396, 714466, 
	11780668, 3854380, 2864788, 3367557, 17176662, 4284549, 13361436, 10909690, 
	5662648, 20013538, 658903, 15972170, 21217981, 4609315, 9951066, 19402596, 
	7053667, 8322016, 23434228, 13404924, 13913031, 2105925, 18838326, 14163140, 
	4921107, 9575009, 9937000, 19546739, 19375632, 21630522, 10147723, 22484054, 
	13439928, 15861482, 16419956, 9656808, 12932610, 10839328, 18265275, 3374002, 
	18629773, 11606388, 17084139, 1765019, 20048768, 1514547, 13666815, 5352612, 
	3480411, 17990635, 12952689, 9211702, 13882855, 19008526, 10986181, 23116824, 
	19964664, 18697601, 9466084, 2506326, 24073793, 14753044, 8790820, 9708221, 
	24228971, 7208849, 17688928, 14334567, 9481274, 7371674, 16473456, 6537685, 
	12028204, 4098617, 1289514, 13983317, 14471698, 9033902, 20981163, 5469416, 
	2022832, 17891765, 5676480, 312359, 22656615, 5503238, 22819544, 5322849, 
	20146931, 9407208, 13480499, 23469114, 11819381, 9165999, 2396970, 16234572, 
	18398616, 17370133, 472538, 20332087, 4772723, 4224102, 15248084, 15396923, 
	22709210, 6825987, 4331205, 5194852, 7049686, 4504340, 3475913, 19390757, 
	19945079, 6237032, 18023580, 9445552, 13002846, 4494503, 24328270, 6236605, 
	10095847, 12427577, 22809131, 14906987, 18607544, 2655341, 12416880, 6939996, 
	22030390, 4097841, 19977467, 6773786, 17673213, 11837888, 9955962, 3211264, 
	1111770, 14853423, 13447, 19253872, 20855238, 19021977, 4187906, 5875103, 
	22060479, 12622409, 14923233, 24182508, 18215643, 12495550, 23297188, 15232130, 
	23511266, 5674540, 16142088, 16836308, 12847993, 5422468, 22123623, 1455064, 
	1270490, 7297144, 21255422, 7170518, 11720297, 19647223, 7346201, 13019532, 
	10342257, 12689437, 20272771, 15477210, 18838965, 529012, 6754252, 4094060, 
	15512218, 11823522, 6739678, 16127286, 10743484, 4870855, 19650220, 16411064, 
	905545, 11339847, 22109712, 22465779, 20415417, 18730889, 2171816, 8167773, 
	15935658, 1641428, 18790805, 13243217, 22110022, 9614397, 4321016, 21053743, 
	14690457, 1079851, 2516831, 11741740, 19721353, 5663497, 428187, 3100238, 
	17474883, 12817710, 18545653, 14949461, 20386495, 4097134, 4450528, 10568790, 
	3897882, 7663527, 5256141, 22893591, 3727932, 9152913, 23459753, 15772507, 
	8345128, 22769122, 22922376, 14859924, 22512032, 17021704, 22227712, 16253515, 
	21881877, 3626026, 12042861, 22022544, 21064192, 13540703, 70937, 3384347, 
	14353923, 1621595, 17303326, 1687075, 9231216, 14536708, 13945273, 19055187, 
	11164301, 20675842, 6442727, 5285253, 15820935, 22966923, 7226846, 10601793, 
	15890789, 18015333, 18339407, 18568047, 11817044, 14686573, 20127298, 22026949, 
	8992301, 4381722, 7879206, 1611018, 14585347, 6193066, 23868455, 23259646, 
	3931109, 17266128, 1146245, 22258210, 22748412, 5562161, 20017457, 10596712, 
	21470874, 5441662, 23179221, 5915612, 21938410, 10392815, 9097607, 3401801, 
	23973406, 20594347, 23552532, 9449813, 23521865, 18579211, 16344999, 18883852, 
	9798360, 7351069, 7283417, 13264808, 6107992, 991680, 10683828, 18207578, 
	24097893, 2887639, 98695, 12046660, 21269788, 3950216, 1367967, 10000490, 
	1986896, 13121932, 104337, 774769, 8077889, 15094967, 15830483, 11969050, 
	15681611, 11535027, 12511037, 18996635, 848647, 19513452, 1766991, 3055032, 
	3613012, 5575905, 14372104, 1785385, 1309013, 3334460, 2981265, 23930974, 
	1490604, 22450050, 9670069, 15305591, 11857290, 1181211, 19840811, 16749191, 
	10917979, 21626454, 1554344, 2855659, 17787726, 9807213, 19823366, 14468716, 
	22878708, 21297123, 23154362, 19990623, 14200058, 11724670, 14944886, 22237997, 
	14434445, 17181830, 16972717, 10477338, 3736040, 1049291, 23877491, 22679535, 
	1027231, 12730076, 4501944, 23505310, 2556388, 567278, 20547262, 12709153, 
	6555683, 23182289, 19330574, 22638174, 8709139, 8076504, 22658136, 22768271, 
	5579306, 5537881, 2614243, 14623981, 11741002, 18694569, 24108359
};



static const uint32_t iGMb_large[] = {
	65536, 10297394, 19869846, 18051901, 7501546, 18426595, 10914687, 1260573, 16515748, 
	16671460, 24165886, 12885082, 7892191, 14036538, 3738593, 17491948, 9027145, 
	16302368, 11856455, 8604124, 5453199, 4314442, 18674657, 13629263, 10344887, 
	8697056, 2330556, 1351009, 16848664, 5040771, 400872, 11950623, 3380018, 
	10935191, 10436338, 8048079, 4797666, 12078293, 19505381, 24145196, 14329827, 
	8965400, 22417400, 10937023, 6558706, 18672898, 11581732, 6704643, 20407780, 
	8642942, 4479307, 1287559, 8678271, 22069378, 17663488, 13198435, 10049976, 
	10391681, 12777013, 12479476, 13704156, 22143839, 13113312, 18470784, 14034478, 
	11120043, 6859656, 9967010, 19034086, 12044991, 10805844, 17946882, 17502966, 
	7039825, 9235181, 3986722, 4297258, 19632709, 16499315, 15764566, 20337662, 
	14302650, 5793481, 22951126, 2200034, 14838800, 942355, 12522322, 20156231, 
	13609867, 2195317, 14220537, 21215475, 21055994, 23333145, 15966653, 2391626, 
	10209284, 15848030, 9320, 20948866, 2053156, 6588612, 14122431, 2129005, 
	24352943, 18549373, 11251109, 8622068, 18686971, 15443469, 14222676, 12987305, 
	19526719, 14470205, 8753061, 13918342, 13733670, 22029640, 7059012, 12090685, 
	11462181, 12939902, 103633, 23284865, 22651828, 12621050, 8330996, 15065098, 
	22327430, 19688422, 11890830, 10859734, 22086847, 146861, 12036317, 20103805, 
	12947453, 12076353, 4559450, 17945156, 8138138, 2227772, 19809416, 16644462, 
	24363004, 22541552, 18961989, 10360778, 18085981, 17146583, 21027651, 20355369, 
	20669809, 23442302, 22466019, 860908, 8459683, 8722050, 16879483, 6639391, 
	7821720, 543111, 22377320, 19722806, 23812315, 3494844, 6576882, 10669436, 
	16552948, 18601789, 19725363, 4414500, 7276013, 5473790, 3194717, 14727948, 
	22133599, 11742862, 1637160, 4700013, 629279, 3107793, 10201358, 9762936, 
	13961374, 22948550, 4752423, 14836975, 8151680, 14003169, 13354817, 12285606, 
	17824516, 16023472, 17468248, 23479755, 4416785, 19715143, 5893221, 16393858, 
	23322279, 6651995, 22223148, 4911661, 22300822, 8118833, 13607824, 14148493, 
	5718892, 15718067, 16141993, 17322698, 890567, 15004471, 9103217, 15835868, 
	6430179, 22364717, 15782569, 2987288, 8822141, 24386263, 758887, 722737, 
	17498845, 8738649, 10145038, 10956823, 10389858, 2117140, 18425523, 16112990, 
	13611401, 6452567, 22043197, 11175327, 21405876, 10619073, 15172648, 17276364, 
	628220, 6755829, 13360935, 9286775, 20011158, 18977746, 18056628, 23222729, 
	16696303, 17408494, 162689, 16142132, 20116526, 24117502, 3185229, 5978572, 
	20134266, 12858079, 21288727, 19579105, 8345699, 7196189, 4010549, 8804805, 
	24249172, 5972313, 3749681, 659168, 8256106, 11532664, 18786785, 10146285, 
	22249228, 6219203, 1669903, 19537302, 7559593, 10343173, 5259177, 21131441, 
	12131960, 1541871, 2518086, 17777451, 24011811, 12460753, 21662314, 8038626, 
	17158665, 2205398, 22578876, 14542895, 19672508, 398069, 4975685, 10254503, 
	5662099, 8427144, 14668188, 21054172, 14826063, 24145300, 10098887, 13865263, 
	10636547, 14038295, 6999717, 10637268, 6427630, 5839611, 11725722, 14650085, 
	710178, 1755064, 13205358, 19207586, 8919664, 2758133, 19802967, 16225710, 
	19154849, 4124816, 1697717, 3377068, 21166137, 14167408, 20290378, 22273730, 
	20067785, 8656222, 15024448, 21008020, 18830474, 7310161, 7793269, 9879009, 
	11748257, 13567012, 9932345, 18972808, 19230742, 3007849, 6730895, 19339261, 
	22194279, 21961329, 16727610, 24341907, 17365212, 23388919, 12778422, 11007072, 
	3196970, 13274104, 8966042, 24336466, 20962222, 6111696, 24197151, 8511198, 
	7968542, 23291291, 6206849, 10636121, 23792202, 7786716, 11248522, 16702442, 
	6375739, 13744088, 20102749, 15725237, 4265102, 2441996, 6121296, 15189835, 
	12686494, 23176812, 7971761, 9939156, 9428134, 10219630, 9633975, 4292274, 
	7927205, 18831611, 242670, 5202656, 4435575, 16938495, 743742, 3398899, 
	3252851, 13197131, 93050, 15309314, 10128142, 3034082, 15845463, 20263798, 
	17432702, 15403118, 1881288, 10173502, 19297011, 21768354, 3417753, 11373679, 
	7893376, 9942369, 13409165, 14462553, 6647984, 20600219, 1340685, 19561510, 
	12114096, 19935199, 456680, 1398712, 2976480, 5550455, 8601971, 6693081, 
	21756239, 5858760, 14349439, 7561635, 12601062, 111710, 13513976, 1794879, 
	4934632, 1235856, 13980292, 23008651, 13959723, 5542556, 4193014, 6674581, 
	284926, 23879173, 5078017, 18234499, 11622727, 8255425, 17706148, 19178636, 
	23276498, 23239742, 3843215, 15422265, 6067373, 3889070, 11576636, 18764375, 
	24384903, 135755, 23366266, 4085061, 11911485, 6142925, 11235974, 23699580, 
	8584461, 24229715, 14276309, 10315582, 7489718, 11264477, 12140249, 4308004, 
	21051549, 15897612, 1318299, 12513537, 11138307, 7969222, 2007899, 3003367, 
	17790720, 19604352, 6682379, 23136341, 16151330, 11997676, 8843780, 18758643, 
	11236047, 16569080, 17385359, 20152183, 2927369, 19642728, 24218584, 3839299, 
	11469187, 12590446, 21192993, 20611744, 4393214, 12341770, 2859017, 1470139, 
	24249679, 22271802, 12953995, 21747855, 5889673, 16431486, 15008091
};


// string rawdb_file = "RawDB_test.csv";
string rawdb_file = "db6k.dat";
string eidxdb_file = "EDB_test.csv";
string bloomfilter_file = "bloom_filter.dat";
string xtag_file = "xtag_search.dat";
string xtag_file_check = "xtag_search_check.dat";


unsigned char **BF;

unsigned char *UIDX;

//db6k.dat
int N_keywords = 6043;
int N_max_ids = 9690;
int N_row_ids = N_max_ids;
int N_words = N_keywords;
int N_max_id_words = 1809;
int N_kw_id_max = 80901;
int N_threads = 1;


//RawDB_test.csv
// int N_keywords = 5;
// int N_max_ids = 37;
// int N_row_ids = N_max_ids;
// int N_words = N_keywords;
// int N_kw_id_pairs = 42;             
// int N_max_id_words = N_kw_id_pairs;
// int N_threads = 1;




int sym_block_size = N_threads*16;
int hash_block_size = N_threads*64;
int bhash_block_size = N_threads*64;
int bhash_in_block_size = N_threads*40;



//IVs and Keys for AES-256 GCM encryption
unsigned char iv_ki[16], iv_r[16], iv_ke[16];
unsigned char tag_r[100], tag_ec[100], tag_kz[100], tag_ks[100], tag_ki[100], tag_kx[100], tag_kt[100],tag_stag[100]; 
unsigned char aad[16]="00000002";
int ke, kw, ka, kec, kt, k_stag, k_stag_query, k_stag_TSetRetrieve;
int kw_dec;
vector<int> kid_enc_vec, kid_dec_vec, kr_enc_vec;


unsigned char iv_ks[16] = {0x56,0x37,0xca,0x94,0xd5,0xe0,0xad,0x62,0x73,0x7c,0xba,0x48,0x8d,0x2d,0x4d,0xde};
unsigned char iv_ec[16] = {0x56,0x37,0xca,0x94,0xd5,0xe0,0xad,0x62,0x73,0x7c,0xba,0x48,0x8d,0x2d,0x4d,0xde};
unsigned char iv_kt[16] = {0x56,0x37,0xca,0x94,0xd5,0xe0,0xad,0x62,0x73,0x7c,0xba,0x48,0x8d,0x2d,0x4d,0xde};
unsigned char iv_stag[16] = {0x56,0x37,0xca,0x94,0xd5,0xe0,0xad,0x62,0x73,0x7c,0xba,0x48,0x8d,0x2d,0x4d,0xde};
unsigned char iv_kx[16] = {0x56,0x37,0xca,0x94,0xd5,0xe0,0xad,0x62,0x73,0x7c,0xba,0x48,0x8d,0x2d,0x4d,0xde};
unsigned char iv_kz[16] = {0x56,0x37,0xca,0x94,0xd5,0xe0,0xad,0x62,0x73,0x7c,0xba,0x48,0x8d,0x2d,0x4d,0xde};


unsigned char KS[32] = {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};
unsigned char KI[32] = {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};
unsigned char KZ[32] = {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};
unsigned char KX[32] = {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};
unsigned char KR[32] = {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};
unsigned char KT[32] = {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};




const char* KS1 = reinterpret_cast<const char *> (KS);
const char* KZ1 = reinterpret_cast<const char *> (KZ);
const char* KI1 = reinterpret_cast<const char *> (KI);
const char* KX1 = reinterpret_cast<const char *> (KX);
const char* KR1 = reinterpret_cast<const char *> (KR);
const char* KT1 = reinterpret_cast<const char *> (KT);





//For Bloom Filter Implementation
unsigned char* GL_BLOOM_MSG = new unsigned char[40*N_max_id_words];
unsigned char* GL_BLOOM_DGST = new unsigned char[64*N_max_id_words];
unsigned char* GL_HASH_DGST = new unsigned char[64*N_max_id_words];
unsigned char* GL_HASH_MSG = new unsigned char[32*N_max_id_words];
unsigned char* GL_BLM_MSG = new unsigned char[40];
unsigned char* GL_BLM_DGST = new unsigned char[64];

unsigned char* GL_MGDB_RES = new unsigned char[N_max_id_words*49]; 
unsigned char* GL_MGDB_BIDX = new unsigned char[N_max_id_words*2];
unsigned char* GL_MGDB_JIDX = new unsigned char[N_max_id_words*2];
unsigned char* GL_MGDB_LBL = new unsigned char[N_max_id_words*12];

unsigned char* MGDB_RES;
unsigned char* MGDB_BIDX;
unsigned char* MGDB_JIDX;
unsigned char* MGDB_LBL;

sw::redis::ConnectionOptions connection_options;
sw::redis::ConnectionPoolOptions pool_options;

// // ---------------------------------------------------------------------------------------------------------------------------------- // //



int Sys_Init()
{
    
    connection_options.host = "127.0.0.1";  
    BloomFilter_Init(BF);

    return 0;
}

int Sys_Clear()
{
    BloomFilter_Clean(BF);

    return 0;
}


//For Falcon random plynomial generation (HashToPoint)
static void *
xmalloc(size_t len)
{
	void *buf;

	if (len == 0) {
		return NULL;
	}
	buf = malloc(len);
	if (buf == NULL) {
		fprintf(stderr, "memory allocation error\n");
		exit(EXIT_FAILURE);
	}
	return buf;
}


/*
 * Reduce a small signed integer modulo q. The source integer MUST
 * be between -q/2 and +q/2.
 */
static inline uint32_t
mq_conv_small(int x)
{
	/*
	 * If x < 0, the cast to uint32_t will set the high bit to 1.
	 */
	uint32_t y;

	y = (uint32_t)x;
	// y += q_l & -(y >> 31);
    y += p_l & -(y >> 31);
	return y;
}


/*
 * Addition modulo q. Operands must be in the 0..q-1 range.
 */
static inline uint32_t
mq_add(uint32_t x, uint32_t y)
{
	/*
	 * We compute x + y - q. If the result is negative, then the
	 * high bit will be set, and 'd >> 31' will be equal to 1;
	 * thus '-(d >> 31)' will be an all-one pattern. Otherwise,
	 * it will be an all-zero pattern. In other words, this
	 * implements a conditional addition of q.
	 */
	uint32_t d;

	// d = x + y - q_l;
	// d += q_l & -(d >> 31);
    d = x + y - p_l;
	d += p_l & -(d >> 31);
	return d;
}

static inline uint32_t
mq_add_large(uint32_t x, uint32_t y)
{
	/*
	 * We compute x + y - q. If the result is negative, then the
	 * high bit will be set, and 'd >> 31' will be equal to 1;
	 * thus '-(d >> 31)' will be an all-one pattern. Otherwise,
	 * it will be an all-zero pattern. In other words, this
	 * implements a conditional addition of q.
	 */
	uint32_t d;

	d = x + y - p_l_dash;
	d += p_l_dash & - (d >> 31);
	return d;
}


/*
 * Subtraction modulo q. Operands must be in the 0..q-1 range.
 */
static inline uint32_t
mq_sub(uint32_t x, uint32_t y)
{
	/*
	 * As in mq_add(), we use a conditional addition to ensure the
	 * result is in the 0..q-1 range.
	 */
	uint32_t d;

	d = x - y;
	// d += q_l & -(d >> 31);
    d += p_l & - (d >> 31);
	return d;
}

static inline uint32_t
mq_sub_large(uint32_t x, uint32_t y)
{
	/*
	 * As in mq_add(), we use a conditional addition to ensure the
	 * result is in the 0..q-1 range.
	 */
	uint32_t d;

	d = x - y;
	d += p_l_dash & - (d >> 31);
	return d;
}



/*
 * Division by 2 modulo q. Operand must be in the 0..q-1 range.
 */
static inline uint32_t
mq_rshift1(uint32_t x)
{
	// x += q_l & -(x & 1);
    x += p_l & -(x & 1);
	return (x >> 1);
}

static inline uint32_t
mq_rshift1_large(uint32_t x)
{
	x += p_l_dash & -(x & 1);
	return (x >> 1);
}


/*
 * Montgomery multiplication modulo q. If we set R = 2^16 mod q, then
 * this function computes: x * y / R mod q
 * Operands must be in the 0..q-1 range.
 */
static inline uint32_t
mq_montymul(uint32_t x, uint32_t y)
{
	uint32_t z, w;

	/*
	 * We compute x*y + k*q with a value of k chosen so that the 16
	 * low bits of the result are 0. We can then shift the value.
	 * After the shift, result may still be larger than q, but it
	 * will be lower than 2*q, so a conditional subtraction works.
	 */

	z = x * y;
	// w = ((z * Q0I) & 0xFFFF) * q_l;
    w = ((z * Q0I) & 0xFFFF) * p_l;

	/*
	 * When adding z and w, the result will have its low 16 bits
	 * equal to 0. Since x, y and z are lower than q, the sum will
	 * be no more than (2^15 - 1) * q + (q - 1)^2, which will
	 * fit on 29 bits.
	 */
	z = (z + w) >> 16;

	/*
	 * After the shift, analysis shows that the value will be less
	 * than 2q. We do a subtraction then conditional subtraction to
	 * ensure the result is in the expected range.
	 */
	// z -= q_l;
	// z += q_l & -(z >> 31);
    z -= p_l;
	z += p_l & - (z >> 31);
	return z;
}


// static inline uint32_t
// mq_montymul_large(uint32_t x, uint32_t y)
// {
// 	uint32_t z, w;

// 	/*
// 	 * We compute x*y + k*q with a value of k chosen so that the 16
// 	 * low bits of the result are 0. We can then shift the value.
// 	 * After the shift, result may still be larger than q, but it
// 	 * will be lower than 2*q, so a conditional subtraction works.
// 	 */

// 	z = x * y;
// 	w = ((z * Q0I_large) & 0xFFFF) * p_l_dash;

// 	/*
// 	 * When adding z and w, the result will have its low 16 bits
// 	 * equal to 0. Since x, y and z are lower than q, the sum will
// 	 * be no more than (2^15 - 1) * q + (q - 1)^2, which will
// 	 * fit on 29 bits.
// 	 */
// 	z = (z + w) >> 16;

// 	/*
// 	 * After the shift, analysis shows that the value will be less
// 	 * than 2q. We do a subtraction then conditional subtraction to
// 	 * ensure the result is in the expected range.
// 	 */
// 	z -= p_l_dash;
// 	z += p_l_dash & -(z >> 31);
// 	return z;
// }

static inline uint32_t mq_montymul_large(uint32_t x, uint32_t y) {
    uint64_t z, w;

    // Compute x * y (64-bit to avoid overflow)
    z = (uint64_t)x * y;

    // Modular reduction step
    w = ((z * Q0I_large) & 0xFFFF) * (uint64_t)p_l_dash;
    w &= 0xFFFFFFFF; // Ensure w fits into 32 bits

    // Add and shift
    z = (z + w) >> 25;

    // Conditional subtraction
    if (z >= p_l_dash) {
        z -= p_l_dash;
    }

	// printf("z = %d", (z));
	// printf("\n");

    return (uint32_t)z;
}



/*
 * Montgomery squaring (computes (x^2)/R).
 */
static inline uint32_t
mq_montysqr(uint32_t x)
{
	return mq_montymul(x, x);
}


/*
 * Divide x by y modulo q = 12289.
 */
static inline uint32_t
mq_div_12289(uint32_t x, uint32_t y)
{
	/*
	 * We invert y by computing y^(q-2) mod q.
	 *
	 * We use the following addition chain for exponent e = 12287:
	 *
	 *   e0 = 1
	 *   e1 = 2 * e0 = 2
	 *   e2 = e1 + e0 = 3
	 *   e3 = e2 + e1 = 5
	 *   e4 = 2 * e3 = 10
	 *   e5 = 2 * e4 = 20
	 *   e6 = 2 * e5 = 40
	 *   e7 = 2 * e6 = 80
	 *   e8 = 2 * e7 = 160
	 *   e9 = e8 + e2 = 163
	 *   e10 = e9 + e8 = 323
	 *   e11 = 2 * e10 = 646
	 *   e12 = 2 * e11 = 1292
	 *   e13 = e12 + e9 = 1455
	 *   e14 = 2 * e13 = 2910
	 *   e15 = 2 * e14 = 5820
	 *   e16 = e15 + e10 = 6143
	 *   e17 = 2 * e16 = 12286
	 *   e18 = e17 + e0 = 12287
	 *
	 * Additions on exponents are converted to Montgomery
	 * multiplications. We define all intermediate results as so
	 * many local variables, and let the C compiler work out which
	 * must be kept around.
	 */
	uint32_t y0, y1, y2, y3, y4, y5, y6, y7, y8, y9;
	uint32_t y10, y11, y12, y13, y14, y15, y16, y17, y18;

	y0 = mq_montymul(y, R2);
	y1 = mq_montysqr(y0);
	y2 = mq_montymul(y1, y0);
	y3 = mq_montymul(y2, y1);
	y4 = mq_montysqr(y3);
	y5 = mq_montysqr(y4);
	y6 = mq_montysqr(y5);
	y7 = mq_montysqr(y6);
	y8 = mq_montysqr(y7);
	y9 = mq_montymul(y8, y2);
	y10 = mq_montymul(y9, y8);
	y11 = mq_montysqr(y10);
	y12 = mq_montysqr(y11);
	y13 = mq_montymul(y12, y9);
	y14 = mq_montysqr(y13);
	y15 = mq_montysqr(y14);
	y16 = mq_montymul(y15, y10);
	y17 = mq_montysqr(y16);
	y18 = mq_montymul(y17, y0);

	/*
	 * Final multiplication with x, which is not in Montgomery
	 * representation, computes the correct division result.
	 */
	return mq_montymul(y18, x);
}



/*
 * Compute NTT on a ring element.
 */
static void
mq_NTT(uint16_t *a, unsigned logn)
{
	size_t n, t, m;

	n = (size_t)1 << logn;
	t = n;
	for (m = 1; m < n; m <<= 1) {
		size_t ht, i, j1;

		ht = t >> 1;
		for (i = 0, j1 = 0; i < m; i ++, j1 += t) {
			size_t j, j2;
			uint32_t s;

			s = GMb[m + i];
			j2 = j1 + ht;
			for (j = j1; j < j2; j ++) {
				uint32_t u, v;

				u = a[j];
				v = mq_montymul(a[j + ht], s);
				a[j] = (uint16_t)mq_add(u, v);
				a[j + ht] = (uint16_t)mq_sub(u, v);
			}
		}
		t = ht;
	}
}


static void
mq_NTT_large(uint32_t *a, unsigned logn)
{
	size_t n, t, m;

	n = (size_t)1 << logn;
	t = n;
	for (m = 1; m < n; m <<= 1) {
		size_t ht, i, j1;

		ht = t >> 1;
		for (i = 0, j1 = 0; i < m; i ++, j1 += t) {
			size_t j, j2;
			uint64_t s;

			s = GMb_large[m + i];
			j2 = j1 + ht;
			for (j = j1; j < j2; j ++) {
				uint64_t u, v;

				u = a[j];
				v = mq_montymul_large(a[j + ht], s);
				a[j] = (uint32_t)mq_add_large(u, v);
				a[j + ht] = (uint32_t)mq_sub_large(u, v);
			}
		}
		t = ht;
	}
}


/*
 * Compute the inverse NTT on a ring element, binary case.
 */
static void
mq_iNTT(uint16_t *a, unsigned logn)
{
	size_t n, t, m;
	uint32_t ni;

	n = (size_t)1 << logn;
	t = 1;
	m = n;
	while (m > 1) {
		size_t hm, dt, i, j1;

		hm = m >> 1;
		dt = t << 1;
		for (i = 0, j1 = 0; i < hm; i ++, j1 += dt) {
			size_t j, j2;
			uint32_t s;

			j2 = j1 + t;
			s = iGMb[hm + i];
			for (j = j1; j < j2; j ++) {
				uint32_t u, v, w;

				u = a[j];
				v = a[j + t];
				a[j] = (uint16_t)mq_add(u, v);
				w = mq_sub(u, v);
				a[j + t] = (uint16_t)
					mq_montymul(w, s);
			}
		}
		t = dt;
		m = hm;
	}

	/*
	 * To complete the inverse NTT, we must now divide all values by
	 * n (the vector size). We thus need the inverse of n, i.e. we
	 * need to divide 1 by 2 logn times. But we also want it in
	 * Montgomery representation, i.e. we also want to multiply it
	 * by R = 2^16. In the common case, this should be a simple right
	 * shift. The loop below is generic and works also in corner cases;
	 * its computation time is negligible.
	 */
	ni = R1;
	for (m = n; m > 1; m >>= 1) {
		ni = mq_rshift1(ni);
	}
	for (m = 0; m < n; m ++) {
		a[m] = (uint16_t)mq_montymul(a[m], ni);
	}
}


static void
mq_iNTT_large(uint32_t *a, unsigned logn)
{
	size_t n, t, m;
	uint64_t ni;

	n = (size_t)1 << logn;
	t = 1;
	m = n;
	while (m > 1) {
		size_t hm, dt, i, j1;

		hm = m >> 1;
		dt = t << 1;
		for (i = 0, j1 = 0; i < hm; i ++, j1 += dt) {
			size_t j, j2;
			uint64_t s;

			j2 = j1 + t;
			s = iGMb_large[hm + i];
			for (j = j1; j < j2; j ++) {
				uint64_t u, v, w;

				u = a[j];
				v = a[j + t];
				a[j] = (uint32_t)mq_add_large(u, v);
				w = mq_sub_large(u, v);
				a[j + t] = (uint32_t) mq_montymul_large(w, s);
			}
		}
		t = dt;
		m = hm;
	}

	/*
	 * To complete the inverse NTT, we must now divide all values by
	 * n (the vector size). We thus need the inverse of n, i.e. we
	 * need to divide 1 by 2 logn times. But we also want it in
	 * Montgomery representation, i.e. we also want to multiply it
	 * by R = 2^16. In the common case, this should be a simple right
	 * shift. The loop below is generic and works also in corner cases;
	 * its computation time is negligible.
	 */
	ni = R1;
	for (m = n; m > 1; m >>= 1) {
		ni = mq_rshift1_large(ni);
	}
	for (m = 0; m < n; m ++) {
		a[m] = (uint32_t) mq_montymul_large(a[m], ni);
	}
}


/*
 * Convert a polynomial (mod q) to Montgomery representation.
 */
static void
mq_poly_tomonty(uint16_t *f, unsigned logn)
{
	size_t u, n;

	n = (size_t)1 << logn;
	for (u = 0; u < n; u ++) {
		f[u] = (uint16_t)mq_montymul(f[u], R2);
	}
}

static void
mq_poly_tomonty_large(uint32_t *f, unsigned logn)
{
	size_t u, n;

	n = (size_t)1 << logn;
	for (u = 0; u < n; u ++) {
		f[u] = mq_montymul_large(f[u], R2_large);
	}
}


/*
 * Multiply two polynomials together (NTT representation, and using
 * a Montgomery multiplication). Result f*g is written over f.
 */
static void
mq_poly_montymul_ntt(uint16_t *f, const uint16_t *g, unsigned logn)
{
	size_t u, n;

	n = (size_t)1 << logn;
	for (u = 0; u < n; u ++) {
		f[u] = (uint16_t)mq_montymul(f[u], g[u]);
	}
}

static void
mq_poly_montymul_ntt_large(uint32_t *f, const uint32_t *g, unsigned logn)
{
	size_t u, n;

	n = (size_t)1 << logn;
	for (u = 0; u < n; u ++) {
		f[u] = mq_montymul_large(f[u], g[u]);
	}
}

/*
 * Subtract polynomial g from polynomial f.
 */
static void
mq_poly_sub(uint16_t *f, const uint16_t *g, unsigned logn)
{
	size_t u, n;

	n = (size_t)1 << logn;
	for (u = 0; u < n; u ++) {
		f[u] = (uint16_t)mq_sub(f[u], g[u]);
	}
}


// void
// Zf(to_ntt_monty)(uint16_t *h, unsigned logn)
// {
// 	mq_NTT(h, logn);
// 	mq_poly_tomonty(h, logn);
// }



void
Zf(to_ntt_monty_large)(uint32_t *h, unsigned logn)
{
	mq_NTT_large(h, logn);
	mq_poly_tomonty_large(h, logn);
}


/* ===================================================================== */

uint32_t scale_to_bits(uint32_t val, uint32_t current_bits, uint32_t target_bits) {
    if (current_bits >= target_bits) {
        return val >> (current_bits - target_bits); // Direct rounding for downscaling
    }

    // Scale value to fit within `target_bits` by left-shifting
    uint32_t scale_factor = target_bits - current_bits;
    return val << scale_factor;
}



// uint32_t round(uint32_t a, uint32_t x_bits, uint32_t y_bits) {
//     if (x_bits <= y_bits) {
//         return a; // No rounding needed
//     }

//     uint32_t shift_amount = x_bits - y_bits;
//     uint32_t bias = 1U << (shift_amount - 1); // Add half of 2^shift_amount for rounding
//     uint32_t rounded_val = (a + bias) >> shift_amount; // Right shift with rounding
//     return rounded_val & ((1U << y_bits) - 1); // Ensure it fits in y_bits range
// }


uint32_t round(uint32_t x, uint32_t q_bits, uint32_t p_bits) {

	float q = pow(2,q_bits);
	float p = pow(2,p_bits);
	return fmod((p * x) / (q), p);
}


// void reduce_mod_phi(ZZ_pX& poly) {
//     int degree_poly = deg(poly);
//     if (degree_poly < 512) {
//         return;  // No reduction needed
//     }

//     for (int i = 512; i <= degree_poly; ++i) {
//         ZZ_p coeff_i = coeff(poly, i);  // Get the coefficient of X^i
//         ZZ_p lower_coeff = coeff(poly, i - 512); // Get the coefficient of X^(i-512)
//         SetCoeff(poly, i - 512, lower_coeff + coeff_i); // Add to X^(i-512)
//         SetCoeff(poly, i, ZZ_p(0)); // Zero out the coefficient of X^i
//     }
//     poly.normalize();  // Clean up trailing zero coefficients
// }



void reduce_mod_phi(ZZX& poly, const ZZ& modulus, int reduction_degree) {
    long degree_poly = deg(poly);  // Degree of the polynomial
    if (degree_poly < reduction_degree) return;  // No reduction needed

    for (long i = reduction_degree; i <= degree_poly; ++i) {
        ZZ coeff_i = coeff(poly, i);
        if (coeff_i != 0) {  // Only process non-zero terms
            ZZ lower_coeff = coeff(poly, i - reduction_degree);
            ZZ new_lower_coeff = (lower_coeff + coeff_i) % modulus;
            SetCoeff(poly, i - reduction_degree, new_lower_coeff);  // Update lower degree
            SetCoeff(poly, i, ZZ(0));  // Zero out higher degree
        }
    }

    poly.normalize();  // Ensure no trailing zeros
}


/////////////////////////////////////////////////////////////////////////////////////////////////



int SHA3_HASH(blake3_hasher *hasher,unsigned char *msg, unsigned char *digest)
{
    Blake3(hasher,digest,msg);
    return 0;
}


int SHA3_HASH_K(blake3_hasher *hasher,unsigned char *msg, unsigned char *digest)
{
    Blake3_K(hasher,digest,msg);
    return 0;
}


int BLOOM_HASH(unsigned char *msg, unsigned char *digest)
{
        blake3_hasher hasher;
        blake3_hasher_init(&hasher);


        ::memset(GL_BLOOM_MSG,0x00,bhash_in_block_size);
        ::memset(GL_BLOOM_DGST,0x00,hash_block_size);
        for(int i=0;i<N_HASH;i++){ 
            ::memcpy(GL_BLOOM_MSG+(40*i),msg,32);
            GL_BLOOM_MSG[40*i+39] = (i & 0xFF);
        }

    
        SHA3_HASH_K(&hasher,GL_BLOOM_MSG,GL_BLOOM_DGST);
        ::memcpy(digest,GL_BLOOM_DGST,hash_block_size);
        
    return 0;
}


int FPGA_HASH(unsigned char *msg, unsigned char *digest)
{
    blake3_hasher hasher;
    blake3_hasher_init(&hasher);
    
    ::memset(GL_HASH_DGST,0x00,hash_block_size);
    ::memcpy(GL_HASH_MSG,msg,sym_block_size);

    SHA3_HASH(&hasher,GL_HASH_MSG,GL_HASH_DGST);

    ::memcpy(digest,GL_HASH_DGST,hash_block_size);

    return 0;
}

int MGDB_QUERY(unsigned char *RES, unsigned char *BIDX, unsigned char *JIDX, unsigned char *LBL)
{
    ::memcpy(GL_MGDB_BIDX,BIDX,(N_threads * 2));
    ::memcpy(GL_MGDB_JIDX,JIDX,(N_threads * 2));
    ::memcpy(GL_MGDB_LBL,LBL,(N_threads * 12));
    ::memset(GL_MGDB_RES,0x00,(N_threads * ((2*N_l+16)+1)));

    auto redis = Redis("tcp://127.0.0.1:6379");

        
    string s = HexToStr(GL_MGDB_BIDX,2) + HexToStr(GL_MGDB_JIDX,2) + HexToStr(GL_MGDB_LBL,12);
    
    auto val = redis.get(s);
    unsigned char *t_res = reinterpret_cast<unsigned char *>(val->data());
    

    DB_StrToHexN(GL_MGDB_RES,t_res,((2*N_l+16)+1));

    ::memcpy(RES,GL_MGDB_RES,((2*N_l+16)+1));

    return 0;
}




int TSet_GetTag(unsigned char *word, unsigned char *stag)
{
    ::memset(stag,0x00,16);
    
    k_stag_query = encrypt(word, sizeof(word)/sizeof(word[0]), aad, sizeof(aad), KT1, iv_kt, stag, tag_kt);
    return 0;
}

int TSet_Retrieve(unsigned char *stag,unsigned char *tset_row, int *n_ids_tset)
{
    unsigned char *stagi;
    unsigned char *stago;
    unsigned char *hashin;
    unsigned char *hashout;
    unsigned char *TV;
    
    int datasize = (2*N_l)+16;

    int N_words = 0;
    unsigned int N_max_id_words = 0;

    N_words = (N_max_ids/N_threads) + ((N_max_ids%N_threads==0)?0:1);
    N_max_id_words = N_words * N_threads;
    
    stagi = new unsigned char[16*N_max_id_words];
    stago = new unsigned char[16*N_max_id_words];
    hashin = new unsigned char[16*N_max_id_words];
    hashout = new unsigned char[64*N_max_id_words];
    TV = new unsigned char[datasize*N_max_id_words];



    unsigned char TENTRY[61];
    unsigned char TVAL[datasize+1];
    unsigned char TBIDX[2];
    unsigned char TJIDX[2];
    unsigned char TLBL[12];
    unsigned char HLBL[12];


    unsigned int *FreeB;
    int bidx=0;
    int len_freeb = 65536;
    int freeb_idx = 0;
    bool BETA = 0;

    unsigned char *stagi_local;
    unsigned char *stago_local;
    unsigned char *hashin_local;
    unsigned char *hashout_local;

    unsigned char * TV_curr;

    unsigned char *T_RES;
    unsigned char *T_BIDX;
    unsigned char *T_JIDX;
    unsigned char *T_LBL;

    unsigned char *local_t_res;
    unsigned char *local_t_bidx;
    unsigned char *local_t_jidx;
    unsigned char *local_t_lbl;
 
    unsigned char *local_t_res_word;
    unsigned char *local_t_bidx_word;
    unsigned char *local_t_jidx_word;
    unsigned char *local_t_lbl_word;
    unsigned char *local_hashout_word;

    T_RES = new unsigned char[(datasize+1)*N_max_id_words];
    T_BIDX = new unsigned char[2*N_max_id_words];
    T_JIDX = new unsigned char[2*N_max_id_words];
    T_LBL = new unsigned char[12*N_max_id_words];

    int rcnt = 0;

    ::memset(stagi,0x00,16*N_max_id_words);
    ::memset(stago,0x00,16*N_max_id_words);
    ::memset(hashin,0x00,16*N_max_id_words);
    ::memset(hashout,0x00,64*N_max_id_words);
    ::memset(TV,0x00,datasize*N_max_id_words);
    

    ::memset(TVAL,0x00,(datasize+1));
    ::memset(TJIDX,0x00,2);

    FreeB = new unsigned int[len_freeb];

    for(int bc=0;bc<len_freeb;++bc){
        FreeB[bc] = 0;
    }

   

    //Fill stagi array
    stagi_local = stagi;
    for(int nword = 0;nword < N_words;++nword){
        for(int nid=0; nid<N_threads; nid++){
            stagi_local[0] = ((nword*N_threads)+nid) & 0xFF;
            stagi_local += 16;
        }
    }
    stagi_local = stagi;

    //PRF of stag and if
    const char* stag1 = reinterpret_cast<const char *> (stag);
    if(!PKCS5_PBKDF2_HMAC_SHA1(stag, strlen(stag),NULL,0,1000,32,stag1))
    {
        printf("Error in key generation\n");
        exit(1);
    }

    stagi_local = stagi;
    hashin_local = hashin;
    for(int nword = 0;nword < N_words;++nword){
        k_stag_TSetRetrieve = encrypt(stagi_local, sizeof(stagi_local)/sizeof(stagi_local[0]), aad, sizeof(aad), stag1, iv_stag, hashin_local, tag_stag);
       
        stagi_local += 16;
        hashin_local += 16;
    }
    stagi_local = stagi;
    hashin_local = hashin;
  

    //Compute Hash
    hashin_local = hashin;
    hashout_local = hashout;
    for(int nword = 0;nword < N_words;++nword){
        FPGA_HASH(hashin_local,hashout_local);
        hashin_local += 16;
        hashout_local += hash_block_size;
    }
    hashin_local = hashin;
    hashout_local = hashout;

    
    TV_curr = TV;

    ::memset(T_RES,0x00,(datasize+1)*N_max_id_words);
    ::memset(T_BIDX,0x00,2*N_max_id_words);
    ::memset(T_JIDX,0x00,2*N_max_id_words);
    ::memset(T_LBL,0x00,12*N_max_id_words);


    local_t_res = T_RES;
    local_t_bidx = T_BIDX;
    local_t_jidx = T_JIDX;
    local_t_lbl = T_LBL;


    while(!BETA){

        local_hashout_word = hashout_local;
        
        local_t_res_word = local_t_res;
        local_t_bidx_word = local_t_bidx;
        local_t_jidx_word = local_t_jidx;
        local_t_lbl_word = local_t_lbl;

        for(unsigned int ni=0;ni<N_threads;++ni){
            ::memcpy(local_t_bidx,hashout_local,2);

            freeb_idx = ((local_t_bidx[1] << 8) + local_t_bidx[0]);

            bidx = (FreeB[freeb_idx]++);
            local_t_jidx[0] =  bidx & 0xFF;
            local_t_jidx[1] =  (bidx >> 8) & 0xFF;

            ::memcpy(local_t_lbl,hashout_local+2,12);
            
            local_t_bidx += 2;
            local_t_jidx += 2;
            local_t_lbl += 12;
            hashout_local +=64;
        }

        MGDB_QUERY(local_t_res,local_t_bidx_word,local_t_jidx_word,local_t_lbl_word);

    
        for(unsigned int ni=0;ni<N_threads;++ni){
          ::memcpy(TVAL,local_t_res,datasize+1);
        //   BETA = TVAL[0] ^ local_hashout_word[15];
            BETA = TVAL[0] ^ 0;

          for(int i=0;i<datasize;++i){
            //   TV_curr[i] = local_hashout_word[16+i] ^ TVAL[i+1];
               TV_curr[i] = 0 ^ TVAL[i+1];
          }

          rcnt++;
          if(BETA == 0x01) break;

          TV_curr += datasize;
          local_t_res += datasize+1;

          local_hashout_word += 64;
        }
    }
    

    *n_ids_tset = rcnt;
    


    ::memcpy(tset_row,TV,datasize*rcnt);


    delete [] stagi;
    delete [] stago;
    delete [] hashin;
    delete [] hashout;
    delete [] TV;

    delete [] FreeB;

    delete [] T_RES;
    delete [] T_BIDX;
    delete [] T_JIDX;
    delete [] T_LBL;
    
   
    return 0;
}


int FPGA_BLOOM_HASH(unsigned char *msg, unsigned char *digest)
{

    blake3_hasher hasher;
    blake3_hasher_init(&hasher);
    
    ::memset(GL_BLM_MSG,0x00,bhash_in_block_size);
    ::memset(GL_BLM_DGST,0x00,bhash_block_size);
    for(int i=0;i<N_HASH;i++){ 
        ::memcpy(GL_BLM_MSG+(40*i),msg,32);
        GL_BLM_MSG[40*i+39] = (i & 0xFF);
    }

    SHA3_HASH_K(&hasher,GL_BLM_MSG,GL_BLM_DGST);

    ::memcpy(digest,GL_BLM_DGST,bhash_block_size);

    return 0;
}


unsigned int BFIdxConv(unsigned char *hex_arr,unsigned int n_bits)
{
    unsigned int idx_val = 0;
    unsigned int n_bytes = n_bits/8;
    unsigned int n_bits_rem = n_bits%8;
    unsigned char tmp_char;
    
    for(unsigned int i=0;i<n_bytes;++i){
        idx_val = (idx_val << 8) | hex_arr[i];
    }

    if(n_bits_rem != 0){
        tmp_char = hex_arr[n_bytes];
        tmp_char = tmp_char >> (8 - n_bits_rem);
        idx_val = (idx_val << n_bits_rem) | tmp_char;
    }

    return idx_val;
}

int32_t extended_gcd(int32_t a, int32_t b, int32_t &x, int32_t &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int32_t x1, y1;
    int32_t gcd = extended_gcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return gcd;
}

int32_t mod_inverse(uint32_t value, uint32_t mod) {
    int32_t x, y;
    int32_t gcd = extended_gcd(value, mod, x, y);
    if (gcd != 1) {
        // std::cout << "Inverse doesn't exist for " << value << " modulo " << mod << std::endl;
        return -1; 
    } else {
        return (uint16_t)(x % mod + mod) % mod;  
    }
}




int EDB_Search(unsigned char *query_str, int NWords)   
{

    unsigned char Q1[16];
   
    unsigned char *stag;
    unsigned char *tset_row;
    unsigned char *tset_yid;
    
    unsigned char *W;
    unsigned char *ID;
    unsigned char *WC;
    unsigned char *EC;
    unsigned char ECE[16];

    unsigned char *YID_char;
    unsigned char *bhash;

    uint16_t* YID;
    uint64_t *XToken;    
    uint64_t *XTAG;    
    
    int datasize = (2*N_l)+16;

    stag = new unsigned char[16*N_max_id_words];
    tset_row = new unsigned char[datasize*N_max_id_words];
    tset_yid = new unsigned char[N_l*2*N_max_id_words];
    
    W = new unsigned char[16*strlen((char *)query_str)];                //Holds the keyword
    ID = new unsigned char[16*N_max_id_words];                          //Maximum number of IDs in a row
    WC = new unsigned char[16*N_max_id_words];                          //IDs with counter value(for computing randomness R)
    EC = new unsigned char[16*N_max_id_words];                           //Encrypted IDs
    UIDX = new unsigned char[16*N_max_ids];

    
    XToken = new uint64_t[N_max_id_words*N_l];
    XTAG = new uint64_t[N_max_id_words*N_l];
    bhash = new unsigned char[bhash_block_size];
    
    YID = new uint16_t [N_l*N_max_id_words];
    YID_char = new unsigned char[N_max_id_words*N_l*2];                        
    

    ofstream xtag_file_handle;
    xtag_file_handle.open(xtag_file,ios_base::out|ios_base::binary);

	ofstream xtag_file_handle_check;
    xtag_file_handle_check.open(xtag_file_check,ios_base::out|ios_base::binary);



    stringstream ss;

    string rawdb_row;
    vector<string> rawdb_data;
    string rawdb_row_current;
    string s;

    int N_words = 0;
    int n_rows = 0;
    int n_row_ids = 0;
    int n_ids_tset = 0;


    //BLoom Filter Parameters
    bool idx_in_set = false;
    int nmatch = 0;
    unsigned int bfidx = 0;

    unsigned int** bf_n_indices;

    bf_n_indices = new unsigned int *[N_HASH];
    for(unsigned int i=0;i<N_HASH;++i){
        bf_n_indices[i] = new unsigned int [NWords];
    }


     
    ::memset(stag,0x00,16*N_max_id_words);
    ::memset(tset_row,0x00,datasize*N_max_id_words);
    ::memset(tset_yid,0x00,2*N_l*N_max_id_words);
    
    ::memset(W,0x00,16);
    ::memset(ID,0x00,N_max_id_words*16);
    ::memset(XTAG,0x00,N_max_id_words*N_l);
   
    ::memset(WC,0x00,N_max_id_words*16);
    ::memset(EC,0x00,N_max_id_words*16);
    ::memset(bhash,0x00,bhash_block_size);

    ::memset(YID_char,0x00,N_max_id_words*2*N_l);
    ::memset(YID,0x00,N_max_id_words*N_l);
   
    ::memset(XToken,0x00, N_max_id_words*N_l);
    ::memset(UIDX,0x00,16*N_max_ids);


    
    unsigned char *id_local = ID;
    unsigned char *wc_local = WC;
    unsigned char *w_local = W;
    unsigned char *ec_local = EC;
    
    uint64_t *xtoken_local = XToken;
    unsigned char *yid_char_local = YID_char;
    uint16_t *yid_local = YID;
    unsigned char *tset_row_local = tset_row;
    unsigned char *tset_yid_local = tset_yid;
    uint64_t *xtag_local = XTAG;
    unsigned char *uidx_local = UIDX;

    unsigned char *local_s;



    ::memcpy(Q1,query_str,16);

    
    TSet_GetTag(Q1,stag);
    TSet_Retrieve(stag,tset_row,&n_ids_tset);
    

    cout << "N IDs TSet: " << n_ids_tset << endl;
    
	
    //Copy all query keywords except first
    ::memcpy(W,query_str+16,(16*NWords));

    w_local = W;

    auto start_time = std::chrono::high_resolution_clock::now();

    
    // Generate random mask for each keyword
    unsigned char r[16];
	int c = 0;
    for(unsigned int nword=0; nword<n_ids_tset; nword++)
    {
        int kr = encrypt(Q1, sizeof(Q1)/sizeof(Q1[0]), aad, sizeof(aad), KZ1, iv_kz, r, tag_kz);
    }

    uint32_t temp = r;
    memcpy(&temp, r, sizeof(uint32_t));

    srand(temp);
    uint16_t mask = (rand()%p_l);
    
    int32_t x, y;
    int32_t gcd = extended_gcd(mask, p_l, x, y);
    if (gcd != 1) {
        mask += 1;
    }

	
    uint16_t inv_mask = mod_inverse(mask,p_l);

	if((mask * inv_mask)%p_l == 1){
		c++;
	}	
	else{	
		mask = (rand()%p_l);

		int32_t x, y;
		int32_t gcd = extended_gcd(mask, p_l, x, y);
		
		if (gcd != 1) {
			mask += 1;
		}

		inv_mask = mod_inverse(mask,p_l);
		if((mask * inv_mask)%p_l == 1){
			c++;
		}
	}

    
    tset_row_local = tset_row;
    tset_yid_local = tset_yid;
    ec_local = EC;
    for(int i=0; i<n_ids_tset; i++){

        ::memcpy(tset_yid_local,tset_row_local,(N_l*2));
        ::memcpy(ec_local,tset_row_local+(N_l*2),16);


        tset_row_local += datasize;
        tset_yid_local += (N_l*2);
        ec_local += 16;
    }


    yid_local = YID;           
    tset_yid_local = tset_yid; 
    for(int n = 0; n < n_ids_tset; n++) {
        for(int k = 0; k < N_l; k++) {
            yid_local[k] = static_cast<int16_t>(tset_yid_local[2*k]) | (static_cast<int16_t>(tset_yid_local[2*k + 1]) << 8);
		}
        yid_local += N_l;             
        tset_yid_local += 2 * N_l; 
    }
    yid_local = YID;          
    tset_yid_local = tset_yid; 



    
    /* Key Generation */

    unsigned char seed[16] = {0x56,0x37,0xca,0x94,0xd5,0xe0,0xad,0x62,0x73,0x7c,0xba,0x48,0x8d,0x2d,0x4d,0xde};
    size_t n_keygen;
    size_t tlen_keygen = 90112;
    size_t tlen_sign = 178176;
    unsigned logn_keygen = 9;
    int8_t *f, *g, *F, *G;
    uint16_t *h, *hm, *h2, *hm2, *h_mont;
    int16_t *sig_keygen, *s1_keygen;
    uint8_t *tt_keygen, *tt_sign, *temp_sign;
    inner_shake256_context sc_keygen;
    fpr *expanded_key;             

    
    // std::memcpy(seed,r_local,16);
    inner_shake256_init(&sc_keygen);
    inner_shake256_inject(&sc_keygen, seed, sizeof(seed));
    inner_shake256_flip(&sc_keygen);
    

    temp_sign = xmalloc(tlen_sign);
    h_mont = (uint16_t *)temp_sign;
    n_keygen = (size_t)1 << logn_keygen;

    f = xmalloc(tlen_keygen);
    g = f + n_keygen;
    F = g + n_keygen;
    G = F + n_keygen;
    h = (uint16_t *)(G + n_keygen);
    h2 = h + n_keygen;
    hm = h2 + n_keygen;
    sig_keygen = (int16_t *)(hm + n_keygen);
    s1_keygen = sig_keygen + n_keygen;
    tt_keygen = (uint8_t *)(s1_keygen + n_keygen);
    tt_sign = (uint8_t *)(s1_keygen + n_keygen);
    if (logn_keygen == 1) {
        tt_keygen += 4;
        tt_sign += 4;
    }
    for (int i = 0; i < 12; i ++) {
        Zf(keygen)(&sc_keygen, f, g, F, G, h, logn_keygen, tt_keygen);
    }

    // Public key h in NTT-Montgomery Form
    ::memcpy(h_mont, h, n_keygen * sizeof *h_mont);
   

	uint16_t h_temp[512];
	for(int i=0; i<512;i++){
		h_temp[i] = h_mont[i];
	}

    
    yid_local = YID;
    id_local = ID;          
    for(int i=0;i<n_ids_tset;++i)
    {
        //Generate xtoken
        xtoken_local = XToken;
        w_local = W;
        for(unsigned int n1=0; n1<NWords; ++n1) 
        {
            //Generate random polynomial wrt XW from Falcon specifications
            TEMPALLOC union {
                uint16_t hm_xw[512];
            } r_xw;
            TEMPALLOC inner_shake256_context sc_xw;

            inner_shake256_init(&sc_xw); 		                            
            inner_shake256_inject(&sc_xw,w_local, 16);	
            inner_shake256_flip(&sc_xw);
            Zf(hash_to_point_vartime)(&sc_xw, r_xw.hm_xw, 9);

           
			uint64_t xw[512];
			size_t n_xw = (size_t)1 << 9;

			for(int i=0; i<512; i++){
				xw[i] = (r_xw.hm_xw[i] << 14) % q_l;
			}

            
            //Xtoken Computation

			ZZ q = power2_ZZ(45);
			ZZ p1 = power2_ZZ(40);

			ZZX h_temp_NTL, xw_NTL, xtoken;

			for(int i=0; i<512; i++){ 
				SetCoeff(h_temp_NTL, i, ZZ(h_temp[i]));
				SetCoeff(xw_NTL, i, ZZ(xw[i]));
			}

			xtoken = h_temp_NTL * xw_NTL;
			for(long i=0; i<=deg(xtoken); i++){ 
				NTL::ZZ coeff = NTL::coeff(xtoken, i);
				coeff = (coeff % q + q) % q; 
				NTL::SetCoeff(xtoken, i, coeff);
			}
			reduce_mod_phi(xtoken, q, N_l);


			for (size_t i = 0; i < 512; i++) {
				xtoken_local[i] = conv<int64_t>((coeff(xtoken, i)) >> (45 - 40));
				xtoken_local[i] = xtoken_local[i] % p_l_dash;
				SetCoeff(xtoken, i, xtoken_local[i]);

				// xtag_file_handle << xtoken_local[i] << " ";
			}
			// xtag_file_handle << endl << endl;
			// xtag_file_handle_check << xtoken << endl << endl;


			
            xtoken_local += N_l;
            w_local += 16;
        }
        xtoken_local = XToken;


        //  XTAG Computation  //
        ::memset(XTAG,0x00, N_max_id_words*N_l);

        int16_t tt_yid[512];
        int16_t yid_temp[512];
		uint32_t tt_yid_large[512];

        for (int u = 0; u < N_l; u ++) {
            uint32_t w;
            w = (uint32_t)yid_local[u];
            w += q_l & - (w >> 31);
            yid_temp[u] = (uint16_t)w;
        }

        for(int i=0; i<512; i++){
            tt_yid[i] = (yid_temp[i] * mask) % p_l; 
			// tt_yid_large[i] = tt_yid[i];	
		}


        if(NWords == 0){
            ::memcpy(ec_local,ECE,16);
            ec_local +=16;
            ++nmatch;
        }

        else {

            xtag_local = XTAG;
            xtoken_local = XToken;
            for(unsigned int n1=0; n1<NWords; ++n1) 
            { 
				ZZ p1 = power2_ZZ(40);

				ZZX yid_NTL, xtoken_NTL, xtag_NTL_temp, xtag_NTL;

				for(int i=0; i<512; i++){
					SetCoeff(yid_NTL,i,ZZ(tt_yid[i]));
					SetCoeff(xtoken_NTL,i,ZZ(xtoken_local[i]));
					
				}
				

				xtag_NTL_temp = yid_NTL * xtoken_NTL;
				for(int i=0; i<=deg(xtag_NTL_temp); i++){ 
					int64_t x = conv<int64_t>((coeff(xtag_NTL_temp, i)));
					x = x % p_l_dash;
					SetCoeff(xtag_NTL_temp, i, x);
				}
				reduce_mod_phi(xtag_NTL_temp, p1, N_l);
				

				for(int i = 0; i <= deg(xtag_NTL_temp); i++){
					xtag_local[i] = conv<int64_t>((coeff(xtag_NTL_temp, i)));
					xtag_local[i] = xtag_local[i] >> (40 - 5);
					xtag_local[i] = xtag_local[i] % p;
					SetCoeff(xtag_NTL_temp, i, xtag_local[i]);
				}
				
				
                xtoken_local += N_l;
                xtag_local += N_l;
        
            }
            xtoken_local = XToken;
            xtag_local = XTAG;


            for(int i=0; i<NWords; ++i){

                ::memset(bhash,0x00,bhash_block_size);

                unsigned char xtag_char[2*N_l];
                ::memset(xtag_char,0x00,2*N_l);


                unsigned char *xtag_char_local = xtag_char;
                for(int k=0; k<N_l; k++){
                    xtag_char[2*k] = static_cast<unsigned char>(xtag_local[k] & 0xFF);          
                    xtag_char[2*k + 1] = static_cast<unsigned char>((xtag_local[k] >> 8) & 0xFF); 

                }
                
                xtag_char_local = xtag_char;

                BLOOM_HASH(xtag_char,bhash);

				xtag_file_handle << DB_HexToStr_N(bhash,bhash_block_size) << endl << endl;


                for(int j=0;j<N_HASH;++j){
                    bf_n_indices[j][i] = BFIdxConv(bhash+(64*j),N_BF_BITS);

					xtag_file_handle_check << bf_n_indices[j][i] << " ";
                }

				xtag_file_handle_check << endl << endl;

                xtag_local += N_l;
            }

            xtag_local = XTAG;

            BloomFilter_Match_N(BF, bf_n_indices, NWords, &idx_in_set);

			cout << idx_in_set << endl;


            if(idx_in_set){
                ::memcpy(ec_local,ECE,16);
                ec_local +=16;
                nmatch++;
            }


        }

        ec_local += 16;
        w_local += 16;
        yid_local += N_l;

        xtag_file_handle << std::endl << "---------" << std::endl;

    }
    yid_local = YID;
    ec_local = EC;
    w_local = W;

    
    
    cout << "Nmatch: " << nmatch << endl;

    
    
    unsigned char KE[32];
    unsigned char KE_temp[16];
    unsigned char dec_pt[16*N_max_id_words];

    unsigned char* ke_temp_local = KE_temp;
    unsigned char* dec_pt_local = dec_pt;
   

    ::memset(KE,0x00,32);
    ::memset(KE_temp,0x00,16);
    ::memset(dec_pt,0x00,16*N_max_id_words);


    //Generate KE from W and KS

    /* Since each W is 8B output of AES-256 is 16B and KE needs to be 32B to be used as a key, thus we run the loop
    four times to generate a block of 8B four times and concatenate in KE to form a block of 32B */                            
    
    for(int i=0; i<4;i++) {
        ::memset(KE_temp,0x00,16);

        if(!PKCS5_PBKDF2_HMAC_SHA1(KS, strlen(KS),NULL,0,1000,32,KS1))
        {
            printf("Error in key generation\n");
            exit(1);
        }
        
        w_local = W;
        ke_temp_local = KE_temp;
        ke = encrypt(w_local, sizeof(w_local)/sizeof(Q1[0]), aad, sizeof(aad), KS1, iv_ks, ke_temp_local, tag_ks);       
        w_local = W;
        ke_temp_local = KE_temp;

        ::memcpy(KE+(8*i),KE_temp,0x08);

    }


    //AES Decryption of ID using KE
    const char* KE1 = reinterpret_cast<const char *> (KE);
    if(!PKCS5_PBKDF2_HMAC_SHA1(KE, strlen(KE),NULL,0,1000,32,KE1))
    {
        printf("Error in key generation\n");
        exit(1);
    }
    while(!RAND_bytes(iv_ec,sizeof(iv_ec)));


    dec_pt_local = dec_pt;
    for(int i=0;i<nmatch;++i) {

       int kd = decrypt(UIDX+(16*i), ke, aad, sizeof(aad), tag_ec, KE1, iv_ec, dec_pt_local);

       ::memcpy(EC+(16*i),dec_pt_local,0x16);
       dec_pt_local += 16;
    }
    dec_pt_local = dec_pt;
    
    

    for(unsigned int i=0;i<N_HASH;++i){
        delete [] bf_n_indices[i];
    }
    delete [] bf_n_indices;

    delete [] stag;
    delete [] tset_row;
    delete [] WC;
    delete [] XTAG;
    delete [] bhash;
    delete [] EC;

    delete [] YID;

    return nmatch;


}   

int main()
{
    cout << "Starting program..." << endl;


    UIDX = new unsigned char[16*N_max_ids];
    ::memset(UIDX,0x00,16*N_max_ids);
    
    std::vector<std::string> query;

    unsigned int n_keywords = 0;
    unsigned int n_iterations = 1;      //Number of text vectors to search

    std::vector<std::string> raw_row_data;
    
    srand(time(NULL));

   
    Sys_Init();
    
    std::cout << "Reading Bloom Filter from disk..." << std::endl;
    BloomFilter_ReadBFfromFile(bloomfilter_file, BF); //Load bloom filter from file
  
    
    auto search_start_time = std::chrono::high_resolution_clock::now();
    auto search_stop_time = std::chrono::high_resolution_clock::now();
    auto search_time_elapsed = std::chrono::duration_cast<std::chrono::microseconds>(search_stop_time - search_start_time).count();

    unsigned int kw_idx = 0;
    unsigned int kw_freq = 0;
    unsigned int n_q_kw = 2;           //Number of keywords in a query to search for

    std::vector<unsigned int> idx_vec;
    std::map<unsigned int,unsigned int> freq_map;
    std::vector<unsigned int> idx_sorted;
    std::vector<unsigned int> freq_sorted;
    std::vector<std::string> kw_sorted;

    unsigned int nm = 0;
    unsigned char row_vec[2048]; //16 bytes * Number of keywords in the query
    int n_vec = 0;
 
    for(unsigned int q_idx=0;q_idx<n_iterations;++q_idx)
    {
        query.clear();

        query.push_back("000012C2");
        query.push_back("00001FF2");

        std::cout << "--------------------------------------------------" << std::endl;
        std::cout << "Searching for  ";
        
        for(auto v:query){
            std::cout << v << " ";
        }
        cout << endl;

        ::memset(row_vec,0x00,2048);
        n_vec = 0;

        for(auto rs:query){
            StrToHexBVec(row_vec+(16*n_vec),rs.data());
            n_vec++;
        } 
        
        ::memset(UIDX,0x00,16*N_max_ids);
        
        search_start_time = std::chrono::high_resolution_clock::now();

        nm = EDB_Search(row_vec,(n_vec-1));

        search_stop_time = std::chrono::high_resolution_clock::now();
        search_time_elapsed = std::chrono::duration_cast<std::chrono::microseconds>(search_stop_time - search_start_time).count();

        std::cout << "Search time = " << search_time_elapsed << " micro-seconds" << std::endl;

        query.clear();
    }

    Sys_Clear();

    return 0;
}

